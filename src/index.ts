import { Plugin } from "vite";
import fs from "fs";
import path from "path";

interface ViteSrcUpdateOptions {
  scriptsInDev: string[];
  devServerAddress: string;
  templateFilePath: string;
  entrypointsDir: string;
  cdn?: boolean;
}

const autoGeneratedComment = `<!-- IMPORTANT: This component is automatically generated by update-vite-tag. -->
<!-- Do not attempt to modify this file directly, as any changes will be overwritten by the next build. -->`;

/**
 * Updates the Vite source file with the necessary script tags based on the provided configuration.
 *
 * @param {Object} options - The configuration options.
 * @param {string[]} options.scriptsInDev - The array of script paths to include in development mode.
 * @param {string} options.devServerAddress - The address of the development server.
 * @param {string} options.templateFilePath - The path to the template file.
 * @param {string} options.entrypointsDir - The directory where the entrypoints are located.
 * @param {boolean} [options.cdn=false] - Whether to use a CDN for the script tags.
 * @returns {Plugin} - The Vite plugin object.
 */
export default function viteSrcUpdate({
  scriptsInDev,
  devServerAddress,
  templateFilePath,
  entrypointsDir,
  cdn = false,
}: ViteSrcUpdateOptions): Plugin {
  let isDevelopment = true; // Default mode is development
  let resolvedPath = path.resolve(templateFilePath);
  let templateFile = path.basename(resolvedPath);

  return {
    name: "update-vite-tag",
    configResolved(config) {
      isDevelopment = config.mode === "development";

      if (isDevelopment) {
        console.log(`Updating ${templateFile} for development...`);

        let devComponentContent = `${autoGeneratedComment}\n`;
        scriptsInDev.forEach((script) => {
          devComponentContent += `<script type="module" src="${devServerAddress}/${script}"></script>\n`;
        });

        try {
          fs.writeFileSync(resolvedPath, devComponentContent);
          console.log(`${templateFile} has been updated for development.`);
        } catch (err) {
          console.error(`Failed to update ${templateFile}:`, err);
        }
      }
    },
    writeBundle(options, bundle) {
      if (isDevelopment) {
        return; // Do not write for development mode
      }
      console.log(
        `Updating ${templateFile} with the latest asset references...`
      );

      let newComponentContent = `${autoGeneratedComment}\n`;

  // Loop over the bundle and conditionally append the necessary elements
  for (const file of Object.values(bundle)) {
    let tag = ''; // Initialize empty string to hold the tag string
    const filePath = `${entrypointsDir}/${file.fileName}`; // Common part of the path

    if (file.type === "chunk" && file.isEntry) {
      const scriptSrc = cdn ? `{{cdn '${filePath}'}}` : filePath;
      tag = `<script type="module" src="${scriptSrc}"></script>\n`;
    } else if (file.type === "asset" && file.fileName.endsWith(".css")) {
      const linkHref = cdn ? `{{cdn '${filePath}'}}` : filePath;
      tag = `<link rel="stylesheet" href="${linkHref}">\n`;
    }

    newComponentContent += tag; // Append tag to the newComponentContent
  }

      try {
        fs.writeFileSync(resolvedPath, newComponentContent);
        console.log(`${templateFile} has been updated.`);
      } catch (err) {
        console.error(`Failed to update ${templateFile}:`, err);
      }
    },
  };
}
