import { Plugin, ResolvedConfig } from "vite";
import fs from "fs";
import path from "path";
import { config } from "process";

interface vitePluginSrcUpdateOptions {
  templateFilePath: string;
  outDir?: string;
  cdn?: boolean;
}

/**
 * Generates auto-generated comment based on the template type.
 * @param {string} templateType - The template file extension.
 * @returns {string} - Formatted comment.
 */
function generateAutoGeneratedComment(templateType: string): string {
  const baseComment = `IMPORTANT: This component is automatically generated by vite-plugin-src-update.
Do not attempt to modify this file directly, as any changes will be overwritten by the next build.`;

  switch (templateType) {
    case ".html":
      return `<!-- ${baseComment} -->`;
    case ".liquid":
      return `{% comment %}\n${baseComment}\n{% endcomment %}`;
    case ".hbs":
      return `{{! ${baseComment.replace(/\n/g, " ")} }}`;
    case ".cshtml":
      return `@* ${baseComment.replace(/\n/g, " ")} *@`;
    default:
      return baseComment; // Fallback for unknown types
  }
}

/**
 * Updates the Vite source file with the necessary script tags based on the provided configuration.
 *
 * @param {Object} options - The configuration options.
 * @param {string} options.templateFilePath - The path to the template file.
 * @param {string} [options.outDir] - The directory where the bundled scripts are outputted. If not provided, it defaults to the output directory specified in the Vite config.
 * @param {boolean} [options.cdn=false] - Whether to use a CDN for the script tags.
 * @returns {Plugin} - The Vite plugin object.
 */
export default function vitePluginSrcUpdate({
  templateFilePath,
  outDir,
  cdn = false,
}: vitePluginSrcUpdateOptions): Plugin {
  let isDevelopment = true;
  let resolvedPath = path.resolve(templateFilePath);
  let templateFile = path.basename(resolvedPath);
  let templateType = path.extname(resolvedPath);
  let devServerAddress = "";
  let resolvedConfig: ResolvedConfig;

  function updateTemplateFileForDevelopment(
    devServerAddress: string,
    config: ResolvedConfig
  ) {
    const resolvedPath = path.resolve(templateFilePath);
    const templateFile = path.basename(resolvedPath);
    const templateType = path.extname(resolvedPath);

    console.log(
      `Updating ${templateFile} for development using address ${devServerAddress}...`
    );

    let basePath = config.base || "/";

    let autoGeneratedComment = generateAutoGeneratedComment(templateType);
    let devComponentContent = `${autoGeneratedComment}\n`;

    if (templateType === ".cshtml") {
      devComponentContent += `<script type="module" src="@Html.Raw("${devServerAddress}${basePath}@vite/client")"></script>\n`;
    } else {
      devComponentContent += `<script type="module" src="${devServerAddress}${basePath}@vite/client"></script>\n`;
    }

    // Handle the rollupOptions input
    const inputs = config.build.rollupOptions.input;

    if (typeof inputs === "object" && inputs !== null) {
      for (const [entryName, entryPath] of Object.entries(inputs)) {
        const relativeOutputPath = `${basePath}${path.relative(
          config.root,
          entryPath
        )}`;

        const formattedPath = relativeOutputPath.replace(/\\/g, "/");

        // Prepending the devServerAddress and ensuring paths start correctly from the base path.
        devComponentContent += `<script type="module" src="${devServerAddress}${
          formattedPath.startsWith("/") ? "" : "/"
        }${formattedPath}"></script>\n`;
      }
    }

    // Write the updated content to the template file
    try {
      fs.writeFileSync(resolvedPath, devComponentContent);
      console.log(`${templateFile} has been updated for development.`);
    } catch (err) {
      console.error(`Failed to update ${templateFile}:`, err);
    }
  }

  return {
    name: "vite-plugin-src-update",

    configResolved(config) {
      resolvedConfig = config;
      isDevelopment = config.mode === "development";

      if (!outDir) {
        outDir = path.relative(config.root, config.build.outDir);
      }
    },

    configureServer(server) {
      if (isDevelopment) {
        // Dynamically determine the dev server's address
        server.httpServer?.on("listening", () => {
          const address = server.httpServer?.address();
          const protocol = server.config.server.https ? "https" : "http";
          if (typeof address === "object" && address !== null) {
            const host =
              address.address === "::" || address.address === "::1"
                ? "localhost"
                : address.address;
            const port = address.port;
            devServerAddress = `${protocol}://${host}:${port}`;

            // Generate content now that devServerAddress is guaranteed to be set
            updateTemplateFileForDevelopment(devServerAddress, server.config);
          }
        });
      }
    },

    writeBundle(options, bundle) {
      if (isDevelopment) {
        return; // Do not write for development mode
      }
      console.log(
        `Updating ${templateFile} with the latest asset references...`
      );

      let autoGeneratedComment = generateAutoGeneratedComment(templateType);
      let newComponentContent = `${autoGeneratedComment}\n`;

      // Loop over the bundle and conditionally append the necessary elements
      for (const file of Object.values(bundle)) {
        let tag = "";
        const filePath = `${outDir}/${file.fileName}`;

        if (file.type === "chunk" && file.isEntry) {
          const scriptSrc = cdn ? `{{cdn '${filePath}'}}` : filePath;
          tag = `<script type="module" src="${scriptSrc}"></script>\n`;
        } else if (file.type === "asset" && file.fileName.endsWith(".css")) {
          const linkHref = cdn ? `{{cdn '${filePath}'}}` : filePath;
          tag = `<link rel="stylesheet" href="${linkHref}">\n`;
        }

        newComponentContent += tag; // Append tag to the newComponentContent
      }

      try {
        fs.writeFileSync(resolvedPath, newComponentContent);
        console.log(`${templateFile} has been updated.`);
      } catch (err) {
        console.error(`Failed to update ${templateFile}:`, err);
      }
    },
  };
}
