import { Plugin, ResolvedConfig, normalizePath } from "vite";
import fs from "fs/promises";
import path from "path";

interface VitePluginSrcUpdateOptions {
  templateFilePath: string;
  input?: string[];
  outDir?: string;
  cdn?: boolean;
  verbose?: boolean;
  dryRun?: boolean;
  commentTemplates?: Record<string, (comment: string) => string>;
}

const DEFAULT_COMMENT = `IMPORTANT: This component is automatically generated by vite-plugin-src-update.
Do not attempt to modify this file directly, as any changes will be overwritten by the next build.`;

const DEFAULT_COMMENT_TEMPLATES: Record<string, (comment: string) => string> = {
  ".html": (c) => `<!-- ${c} -->`,
  ".liquid": (c) => `{% comment %}\n${c}\n{% endcomment %}`,
  ".hbs": (c) => `{{! ${c.replace(/\n/g, " ")} }}`,
  ".cshtml": (c) => `@* ${c.replace(/\n/g, " ")} *@`,
};

const PREFIX = "[vite-plugin-src-update]";

export default function vitePluginSrcUpdate(
  options: VitePluginSrcUpdateOptions | VitePluginSrcUpdateOptions[]
): Plugin[] {
  return (Array.isArray(options) ? options : [options]).map(createVitePlugin);
}

function createVitePlugin({
  input = [],
  templateFilePath,
  outDir,
  cdn = false,
  verbose = false,
  dryRun = false,
  commentTemplates = DEFAULT_COMMENT_TEMPLATES,
}: VitePluginSrcUpdateOptions): Plugin {
  const resolvedPath = path.resolve(templateFilePath);
  const templateFile = path.basename(resolvedPath);
  const templateExt = path.extname(resolvedPath);
  const formatter = commentTemplates[templateExt] ?? ((c: string) => c);
  const autoComment = formatter(DEFAULT_COMMENT);

  let isDev = true;
  let devServerAddress = "";
  let resolvedOutDir = outDir;

  const log = (msg: string) => verbose && console.info(PREFIX, msg);
  const logError = (msg: string, err?: unknown) =>
    console.error(PREFIX, msg, err ?? "");

  async function writeTemplate(content: string): Promise<void> {
    if (dryRun) {
      log(`[DRY RUN] Would update ${templateFile}:\n${content}`);
      return;
    }
    await fs.writeFile(resolvedPath, content);
    console.info(PREFIX, `${templateFile} updated`);
  }

  function getAssetPath(fileName: string): string {
    const formatted = normalizePath(path.join(resolvedOutDir ?? "", fileName));
    return cdn ? `{{cdn '${formatted}'}}` : formatted;
  }

  function getInputPaths(config: ResolvedConfig): string[] {
    if (input.length) return input;

    const inputs = config.build.rollupOptions.input;
    if (!inputs) return [];
    if (typeof inputs === "string") return [inputs];
    if (Array.isArray(inputs)) return inputs;
    return Object.values(inputs);
  }

  function scriptTag(src: string): string {
    return `<script type="module" src="${src}"></script>`;
  }

  function styleTag(href: string): string {
    return `<link rel="stylesheet" href="${href}">`;
  }

  return {
    name: "vite-plugin-src-update",

    configResolved(config) {
      isDev = config.mode === "development";
      resolvedOutDir ??= path.relative(config.root, config.build.outDir);
      log(`${isDev ? "dev" : "prod"} mode, outDir: ${resolvedOutDir}`);
    },

    configureServer(server) {
      if (!isDev) return;

      server.httpServer?.on("listening", async () => {
        const addr = server.httpServer?.address();
        if (!addr || typeof addr !== "object") return;

        const protocol = server.config.server.https ? "https" : "http";
        const host = ["", "::", "::1", "0.0.0.0"].includes(addr.address)
          ? "localhost"
          : addr.address;
        devServerAddress = `${protocol}://${host}:${addr.port}`;

        const base = server.config.base || "/";
        const tags = getInputPaths(server.config).map((p) => {
          const rel = path.isAbsolute(p)
            ? path.relative(server.config.root, p)
            : p;
          return scriptTag(`${devServerAddress}${base}${normalizePath(rel)}`);
        });

        try {
          await writeTemplate([autoComment, ...tags].join("\n") + "\n");
        } catch (err) {
          logError("Failed to update template:", err);
        }
      });
    },

    async writeBundle(_options, bundle) {
      if (isDev) return;

      const tags = Object.values(bundle)
        .filter(
          (f) =>
            (f.type === "chunk" && f.isEntry) ||
            (f.type === "asset" && f.fileName.endsWith(".css"))
        )
        .map((f) =>
          f.type === "chunk"
            ? scriptTag(getAssetPath(f.fileName))
            : styleTag(getAssetPath(f.fileName))
        );

      await writeTemplate([autoComment, ...tags].join("\n") + "\n");
    },
  };
}
