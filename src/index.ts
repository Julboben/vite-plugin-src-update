import { Plugin, ResolvedConfig } from "vite";
import fs from "fs/promises";
import path from "path";

interface VitePluginSrcUpdateOptions {
  templateFilePath: string;
  input?: string[];
  outDir?: string;
  cdn?: boolean;
}

const commentTemplates = new Map([
  [".html", (comment: string) => `<!-- ${comment} -->`],
  [
    ".liquid",
    (comment: string) => `{% comment %}\n${comment}\n{% endcomment %}`,
  ],
  [".hbs", (comment: string) => `{{! ${comment.replace(/\n/g, " ")} }}`],
  [".cshtml", (comment: string) => `@* ${comment.replace(/\n/g, " ")} *@`],
]);

const memoizedGenerateComment = (() => {
  const cache = new Map<string, string>();
  return (templateType: string): string => {
    if (!cache.has(templateType)) {
      const baseComment = `IMPORTANT: This component is automatically generated by vite-plugin-src-update.
Do not attempt to modify this file directly, as any changes will be overwritten by the next build.`;
      const formatter =
        commentTemplates.get(templateType) || ((c: string) => c);
      cache.set(templateType, formatter(baseComment));
    }
    return cache.get(templateType)!;
  };
})();

export default function vitePluginSrcUpdate(
  options: VitePluginSrcUpdateOptions | VitePluginSrcUpdateOptions[]
): Plugin[] {
  return (Array.isArray(options) ? options : [options]).map(createVitePlugin);
}

function createVitePlugin({
  input,
  templateFilePath,
  outDir,
  cdn = false,
}: VitePluginSrcUpdateOptions): Plugin {
  let isDevelopment = true;
  let resolvedPath = path.resolve(templateFilePath);
  let templateFile = path.basename(resolvedPath);
  let templateType = path.extname(resolvedPath);
  let devServerAddress = "";
  let resolvedConfig: ResolvedConfig;
  const inputSet = new Set(input);

  async function updateTemplateFile(content: string) {
    try {
      await fs.writeFile(resolvedPath, content);
      console.log(`${templateFile} has been updated.`);
    } catch (err) {
      console.error(`Failed to update ${templateFile}:`, err);
    }
  }

  async function updateTemplateFileForDevelopment(
    devServerAddress: string,
    config: ResolvedConfig
  ) {
    console.log(
      `Updating ${templateFile} for development using address ${devServerAddress}...`
    );

    let basePath = config.base || "/";
    let autoGeneratedComment = memoizedGenerateComment(templateType);
    let devComponentContent = `${autoGeneratedComment}\n`;

    if (templateType === ".cshtml") {
      devComponentContent += `<script type="module" src="@Html.Raw("${devServerAddress}${basePath}@vite/client")"></script>\n`;
    } else {
      devComponentContent += `<script type="module" src="${devServerAddress}${basePath}@vite/client"></script>\n`;
    }

    if (inputSet.size > 0) {
      console.log("Scripts in dev mode:", Array.from(inputSet));
      for (const script of inputSet) {
        const formattedPath = script.replace(/\\/g, "/");
        devComponentContent += `<script type="module" src="${devServerAddress}${
          formattedPath.startsWith("/") ? "" : "/"
        }${formattedPath}"></script>\n`;
      }
    } else {
      console.log("No scripts in dev mode, using rollupOptions input.");
      const inputs = config.build.rollupOptions.input;

      if (typeof inputs === "object" && inputs !== null) {
        for (const [, entryPath] of Object.entries(inputs)) {
          const relativeOutputPath = `${basePath}${path.relative(
            config.root,
            entryPath
          )}`;
          const formattedPath = relativeOutputPath.replace(/\\/g, "/");
          devComponentContent += `<script type="module" src="${devServerAddress}${
            formattedPath.startsWith("/") ? "" : "/"
          }${formattedPath}"></script>\n`;
        }
      }
    }

    await updateTemplateFile(devComponentContent);
  }

  return {
    name: "vite-plugin-src-update",

    configResolved(config) {
      resolvedConfig = config;
      isDevelopment = config.mode === "development";
      if (!outDir) {
        outDir = path.relative(config.root, config.build.outDir);
      }
    },

    configureServer(server) {
      if (isDevelopment) {
        server.httpServer?.on("listening", () => {
          const address = server.httpServer?.address();
          const protocol = server.config.server.https ? "https" : "http";
          if (typeof address === "object" && address !== null) {
            const host =
              address.address === "::" || address.address === "::1"
                ? "localhost"
                : address.address;
            const port = address.port;
            devServerAddress = `${protocol}://${host}:${port}`;
            updateTemplateFileForDevelopment(devServerAddress, server.config);
          }
        });
      }
    },

    async writeBundle(options, bundle) {
      if (isDevelopment) return;

      console.log(
        `Updating ${templateFile} with the latest asset references...`
      );

      const autoGeneratedComment = memoizedGenerateComment(templateType);
      let newComponentContent = `${autoGeneratedComment}\n`;

      const relevantFiles = Object.values(bundle).filter(
        (file) =>
          (file.type === "chunk" && file.isEntry) ||
          (file.type === "asset" && file.fileName.endsWith(".css"))
      );

      for (const file of relevantFiles) {
        const filePath = `${outDir}/${file.fileName}`;
        const src = cdn ? `{{cdn '${filePath}'}}` : filePath;

        if (file.type === "chunk" && file.isEntry) {
          newComponentContent += `<script type="module" src="${src}"></script>\n`;
        } else if (file.type === "asset" && file.fileName.endsWith(".css")) {
          newComponentContent += `<link rel="stylesheet" href="${src}">\n`;
        }
      }

      await updateTemplateFile(newComponentContent);
    },
  };
}
