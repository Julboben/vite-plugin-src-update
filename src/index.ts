import { Plugin, ResolvedConfig, normalizePath } from "vite";
import fs from "fs/promises";
import path from "path";

interface VitePluginSrcUpdateOptions {
  templateFilePath: string;
  input?: string[];
  outDir?: string;
  cdn?: boolean;
}

const commentTemplates = new Map<string, (comment: string) => string>([
  [".html", (comment: string) => `<!-- ${comment} -->`],
  [
    ".liquid",
    (comment: string) => `{% comment %}\n${comment}\n{% endcomment %}`,
  ],
  [".hbs", (comment: string) => `{{! ${comment.replace(/\n/g, " ")} }}`],
  [".cshtml", (comment: string) => `@* ${comment.replace(/\n/g, " ")} *@`],
]);

const memoizedGenerateComment = (() => {
  const cache = new Map<string, string>();
  return (templateType: string): string => {
    if (!cache.has(templateType)) {
      const baseComment = `IMPORTANT: This component is automatically generated by vite-plugin-src-update.
Do not attempt to modify this file directly, as any changes will be overwritten by the next build.`;
      const formatter =
        commentTemplates.get(templateType) || ((c: string) => c);
      cache.set(templateType, formatter(baseComment));
    }
    return cache.get(templateType)!;
  };
})();

// Main export accepts one or more options objects.
export default function vitePluginSrcUpdate(
  options: VitePluginSrcUpdateOptions | VitePluginSrcUpdateOptions[]
): Plugin[] {
  const opts = Array.isArray(options) ? options : [options];
  return opts.map(createVitePlugin);
}

function createVitePlugin({
  input,
  templateFilePath,
  outDir,
  cdn = false,
}: VitePluginSrcUpdateOptions): Plugin {
  let isDevelopment = true;
  const resolvedPath = path.resolve(templateFilePath);
  const templateFile = path.basename(resolvedPath);
  const templateType = path.extname(resolvedPath);
  let devServerAddress = "";
  let resolvedConfig: ResolvedConfig;
  const inputSet = new Set(input || []);

  const autoComment = memoizedGenerateComment(templateType);

  async function updateTemplateFile(content: string) {
    try {
      await fs.writeFile(resolvedPath, content);
      console.info(`${templateFile} has been updated.`);
    } catch (err) {
      console.error(`Failed to update ${templateFile}:`, err);
    }
  }

  const buildScriptTag = (src: string): string =>
    `<script type="module" src="${src}"></script>`;
  const buildStylesheetTag = (href: string): string =>
    `<link rel="stylesheet" href="${href}">`;

  function getAssetPath(fileName: string): string {
    // Use forward slashes and ensure the base path is used correctly.
    const formattedPath = normalizePath(path.join(outDir || "", fileName));
    return cdn ? `{{cdn '${formattedPath}'}}` : formattedPath;
  }

  async function updateTemplateForDev(config: ResolvedConfig) {
    console.info(
      `Updating ${templateFile} for development using address ${devServerAddress}...`
    );
    const basePath = config.base || "/";
    let scripts: string[] = [];

    if (inputSet.size) {
      console.info("Using explicit dev scripts:", Array.from(inputSet));
      scripts = Array.from(inputSet).map((script) => {
        const normalized = normalizePath(script);
        return buildScriptTag(`${devServerAddress}${basePath}${normalized}`);
      });
    } else {
      console.info("Using rollupOptions input for dev scripts.");
      const inputs = config.build.rollupOptions.input;
      if (inputs && typeof inputs === "object") {
        scripts = Object.values(inputs).map((entryPath) => {
          const relativePath = normalizePath(
            path.relative(config.root, entryPath)
          );
          return buildScriptTag(
            `${devServerAddress}${basePath}${relativePath}`
          );
        });
      }
    }

    const content = [autoComment, ...scripts].join("\n") + "\n";
    await updateTemplateFile(content);
  }

  return {
    name: "vite-plugin-src-update",

    configResolved(config) {
      resolvedConfig = config;
      isDevelopment = config.mode === "development";
      // If outDir is not provided, use the build.outDir relative to the project root.
      if (!outDir) {
        outDir = path.relative(config.root, config.build.outDir);
      }
    },

    configureServer(server) {
      if (!isDevelopment) return;
      // Listen for the server to start and then update the template file.
      server.httpServer?.on("listening", () => {
        const address = server.httpServer?.address();
        const protocol = server.config.server.https ? "https" : "http";
        if (address && typeof address === "object") {
          const host =
            address.address === "::" || address.address === "::1"
              ? "localhost"
              : address.address;
          const port = address.port;
          devServerAddress = `${protocol}://${host}:${port}`;
          updateTemplateForDev(server.config);
        }
      });
    },

    async writeBundle(_options, bundle) {
      if (isDevelopment) return;

      console.info(
        `Updating ${templateFile} with the latest asset references...`
      );

      // Filter for entry chunks and CSS assets.
      const relevantFiles = Object.values(bundle).filter(
        (file) =>
          (file.type === "chunk" && file.isEntry) ||
          (file.type === "asset" && file.fileName.endsWith(".css"))
      );

      const tags = relevantFiles.map((file) => {
        const assetPath = getAssetPath(file.fileName);
        if (file.type === "chunk") {
          return buildScriptTag(assetPath);
        }
        return buildStylesheetTag(assetPath);
      });

      const content = [autoComment, ...tags].join("\n") + "\n";
      await updateTemplateFile(content);
    },
  };
}
